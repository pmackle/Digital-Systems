//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module BCDConverter(

	

	input						[9:0]	twosCompNum,
	input								nothing,
	input								outofrange,
	
	///////////////HEX/////////////////////
	output		     reg [7:0]		out0,
	output		     reg [7:0]		out1,
	output		     reg [7:0]		out2,
	output		     reg [7:0]		out3
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
reg [4:0] hundreds; reg [3:0] hundreds2;
//reg [4:0] hundredsComp; // The negative digit, not needed, negative sign accounts for it
reg [4:0] tens; reg [3:0] tens2;
reg [5:0] ones; reg [3:0] ones2; // These are all 5 bits so as to be able to carry overflow
reg [9:0] twosCompNum2;

always @(*) begin
	out3 = 8'b10111111;
	out2 = 8'b10111111;
	out1 = 8'b10111111;
	out0 = 8'b10111111;
	hundreds = 5'b00000;
	tens = 5'b00000;
	ones = 5'b00000;
	twosCompNum2 = 10'b0000000000;
	
	if (twosCompNum[9] == 1'b1) begin //if 512 bit, make 2's complement of number. Otherwise, keep as is.
		out3 = 8'b10111111;
		twosCompNum2 = -twosCompNum;
	end else begin
		out3 = 8'b11111111;
		twosCompNum2 = twosCompNum;
	end

	#100
	if (twosCompNum2[8] == 1'b1) begin // If 256 bit, Add 2 to hundreds, 5 to tens, and 6 to ones
		hundreds = 5'b00010 + hundreds;
		tens = 5'b00101 + tens;
		ones = 6'b000110 + ones;
	end
	
	#100
	if (twosCompNum2[7] == 1'b1) begin // If 128 bit, add 1 to hundreds, 2 to tens, and 8 to ones
		hundreds = 5'b00001 + hundreds;
		tens = 5'b00010 + tens;
		ones = 6'b001000 + ones;
	end
	
	#100
	if (twosCompNum2[6] == 1'b1) begin // If 64 bit, add 6 to tens, and 4 to ones
		tens = 5'b00110 + tens;
		ones = 6'b000100 + ones;
	end
	#100
	if (twosCompNum2[5] == 1'b1) begin // If 32 bit, add 3 to tens, and 2 to ones
		tens = 5'b00011 + tens;
		ones  = 6'b000010 + ones;
	end
	#100
	if (twosCompNum2[4] == 1'b1) begin // if 16 bit, add 1 to tens, and 6 to ones
		tens = 5'b00001 + tens;
		ones = 6'b000110 + ones;
	end
	#100
	if (twosCompNum2[3] == 1'b1) begin // If 8 bit, add 8 to ones
		ones = 6'b001000 + ones;
	end
	#100
	if (twosCompNum2[2] == 1'b1) begin // If 4 bit, add 4 to ones
		ones = 6'b000100 + ones;
	end
	#100
	if (twosCompNum2[1] == 1'b1) begin // If 2 bit, add 2 to ones
		ones = 6'b000010 + ones;
	end
#100
	if (twosCompNum2[0] == 1'b1) begin // If 1 bit, add 1 to ones
		ones = 6'b000001 + ones;
	end


	if (ones >= 6'b001010 && ones < 6'b010100) begin // If ones >= 10 && < 20, add 1 to tens, and subtract 10 from ones
		tens = 5'b00001 + tens;
		ones = ones - 6'b001010;
		ones2 = ones[3:0];
	end else if (ones >= 6'b010100 && ones < 6'b011110) begin // If ones >= 20 && < 30, add 2 to tens and subtract 20 from ones
		tens = 5'b00010 + tens;
		ones = ones - 6'b010100;
		ones2 = ones[3:0];
	end else if (ones >= 6'b011110 && ones < 6'b101000) begin //If ones >= 30, && ones < 40, add 3 to tens and subtract 30 from ones
		tens = 5'b00011 + tens;
		ones = ones - 6'b011110;
		ones2 = ones[3:0];
	end else if (ones >= 6'b101000 && ones < 6'b110010) begin // If ones >= 40 && ones < 50, add 4 to tens and subract 40 from ones
		tens = 5'b00100 + tens;
		ones = ones - 6'b101000;
		ones2 = ones[3:0]; 
	end else if (ones > 6'b110010) begin // If ones >= 50, add 5 to tens and subtract 50 from ones
		tens = 5'b00101 + tens;
		ones = ones - 6'b110010;
		ones2 = ones[3:0]; // If there is no overflow, assign as normal
	end else begin
		ones2 = ones[3:0];
	end
	
#100
	if (tens >= 5'b01010 && tens < 5'b10100) begin // If tens >= 10 && tens < 20, add 1 to hundreds, and subtract 10 from tens
		hundreds = 5'b000001 + hundreds;
		tens = tens - 5'b01010;
		tens2 = tens[3:0];
	end else if (tens >= 5'b10100 && tens < 5'b11110) begin // If tens >= 20 && tens < 30, add 2 to hundreds and subtract 20 from tens
		hundreds = 5'b00010 + hundreds;
		tens = tens - 5'b10100;
		tens2 = tens[3:0];
	end else begin// If there is no overflow, assign as normal
		tens2 = tens[3:0];
	end
#100
	if (hundreds >= 5'b01010) begin // Will never get here (would mean hundreds >= 10, which would mean decimal 1000)
		hundreds2 = 4'b0000; // this should make it clear something is wrong
	end else begin
		hundreds2 = hundreds[3:0]; // If there is no overflow, assign as normal
	end

#100

		case (hundreds2)
			4'b0000 : out2 = 8'b11000000;
			4'b0001 : out2 = 8'b11111001;
			4'b0010 : out2 = 8'b10100100;
			4'b0011 : out2 = 8'b10110000;
			4'b0100 : out2 = 8'b10011001;
			4'b0101 : out2 = 8'b10010010;
			4'b0110 : out2 = 8'b10000010;
			4'b0111 : out2 = 8'b11111000;
			4'b1000 : out2 = 8'b10000000;
			4'b1001 : out2 = 8'b10011000;
			4'b1010 : out2 = 8'b10001000;
			default : out2 = 8'b00000000;
		endcase

		case (tens2)
			4'b0000 : out1 = 8'b11000000;
			4'b0001 : out1 = 8'b11111001;
			4'b0010 : out1 = 8'b10100100;
			4'b0011 : out1 = 8'b10110000;
			4'b0100 : out1 = 8'b10011001;
			4'b0101 : out1 = 8'b10010010;
			4'b0110 : out1 = 8'b10000010;
			4'b0111 : out1 = 8'b11111000;
			4'b1000 : out1 = 8'b10000000;
			4'b1001 : out1 = 8'b10011000;
			4'b1010 : out1 = 8'b10001000;
			default : out1 = 8'b00000000;
		endcase

		case (ones2)
			4'b0000 : out0 = 8'b11000000;
			4'b0001 : out0 = 8'b11111001;
			4'b0010 : out0 = 8'b10100100;
			4'b0011 : out0 = 8'b10110000;
			4'b0100 : out0 = 8'b10011001;
			4'b0101 : out0 = 8'b10010010;
			4'b0110 : out0 = 8'b10000010;
			4'b0111 : out0 = 8'b11111000;
			4'b1000 : out0 = 8'b10000000;
			4'b1001 : out0 = 8'b10011000;
			4'b1010 : out0 = 8'b10001000;
			default : out0 = 8'b00000000;
		endcase

	
	if (nothing == 1'b1) begin // If nothing signal is high, put dashes on all 4 displays
		out3 = 8'b10111111;
		out2 = 8'b10111111;
		out1 = 8'b10111111;
		out0 = 8'b10111111;
	end
	
	if (outofrange == 1'b1) begin // If out of range, set all digits to 8
		out3 = 8'b10000000;
		out2 = 8'b10000000;
		out1 = 8'b10000000;
		out0 = 8'b10000000;
	end
	
	
end


//=======================================================
//  Structural coding
//=======================================================



endmodule
