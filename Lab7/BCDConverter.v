//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module BCDConverter(

	

	input						[9:0]	unsignedNum,
	input								nothing,
	
	///////////////HEX/////////////////////
	output		     reg [3:0]		hundreds2,
	output		     reg [3:0]		tens2,
	output		     reg [3:0]		ones2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
reg [6:0] hundreds;
reg [6:0] tens; 
reg [6:0] ones; // These are all 7 bits so as to be able to carry overflow

always @(*) begin
	hundreds2 = 4'b0000;
	tens2 = 4'b0000;
	ones2 = 4'b0000;
	hundreds = 7'b0000000;
	tens = 7'b0000000;
	ones = 7'b0000000;
	
	if (unsignedNum[9] == 1'b1) begin //if 512 bit, add 5 to hundreds, 1 to tens, and 2 to ones
		hundreds = 7'b0000101 + hundreds;
		tens = 7'b0000001 + tens;
		ones = 7'b0000010 + ones;
	end

//	#100
	if (unsignedNum[8] == 1'b1) begin // If 256 bit, Add 2 to hundreds, 5 to tens, and 6 to ones
		hundreds = 7'b0000010 + hundreds;
		tens = 7'b0000101 + tens;
		ones = 7'b0000110 + ones;
	end
	
//	#100
	if (unsignedNum[7] == 1'b1) begin // If 128 bit, add 1 to hundreds, 2 to tens, and 8 to ones
		hundreds = 7'b0000001 + hundreds;
		tens = 7'b0000010 + tens;
		ones = 7'b0001000 + ones;
	end
	
//	#100
	if (unsignedNum[6] == 1'b1) begin // If 64 bit, add 6 to tens, and 4 to ones
		tens = 7'b0000110 + tens;
		ones = 7'b0000100 + ones;
	end
//	#100
	if (unsignedNum[5] == 1'b1) begin // If 32 bit, add 3 to tens, and 2 to ones
		tens = 7'b0000011 + tens;
		ones  = 7'b0000010 + ones;
	end
//	#100
	if (unsignedNum[4] == 1'b1) begin // if 16 bit, add 1 to tens, and 6 to ones
		tens = 7'b0000001 + tens;
		ones = 7'b0000110 + ones;
	end
//	#100
	if (unsignedNum[3] == 1'b1) begin // If 8 bit, add 8 to ones
		ones = 7'b0001000 + ones;
	end
//	#100
	if (unsignedNum[2] == 1'b1) begin // If 4 bit, add 4 to ones
		ones = 7'b0000100 + ones;
	end
//	#100
	if (unsignedNum[1] == 1'b1) begin // If 2 bit, add 2 to ones
		ones = 7'b0000010 + ones;
	end
//#100
	if (unsignedNum[0] == 1'b1) begin // If 1 bit, add 1 to ones
		ones = 7'b0000001 + ones;
	end


	if (ones >= 6'b001010 && ones < 6'b010100) begin // If ones >= 10 && < 20, add 1 to tens, and subtract 10 from ones
		tens = 7'b0000001 + tens;
		ones = ones - 7'b0001010;
		ones2 = ones[3:0];
	end else if (ones >= 7'b0010100 && ones < 7'b0011110) begin // If ones >= 20 && < 30, add 2 to tens and subtract 20 from ones
		tens = 7'b0000010 + tens;
		ones = ones - 7'b0010100;
		ones2 = ones[3:0];
	end else if (ones >= 7'b0011110 && ones < 7'b0101000) begin //If ones >= 30, && ones < 40, add 3 to tens and subtract 30 from ones
		tens = 7'b0000011 + tens;
		ones = ones - 7'b0011110;
		ones2 = ones[3:0];
	end else if (ones >= 7'b0101000 && ones < 7'b0110010) begin // If ones >= 40 && ones < 50, add 4 to tens and subract 40 from ones
		tens = 7'b0000100 + tens;
		ones = ones - 7'b0101000;
		ones2 = ones[3:0]; 
	end else if (ones >= 7'b0110010 && ones < 7'b0111100) begin // If ones >= 50 && < 60, add 5 to tens and subtract 50 from ones
		tens = 7'b0000101 + tens;
		ones = ones - 7'b0110010;
		ones2 = ones[3:0]; 
	end else if (ones >= 7'b0111100) begin // If ones >= 60, add 6 to tens and subtract 50 from ones. Shouldnt reach this
		tens = 7'b0000110 + tens;
		ones = ones - 7'b0111100;
		ones2 = ones[3:0];
	end else begin
		ones2 = ones[3:0]; // If there is no overflow, assign as normal
	end
	
//#100
	if (tens >= 7'b0001010 && tens < 7'b0010100) begin // If tens >= 10 && tens < 20, add 1 to hundreds, and subtract 10 from tens
		hundreds = 7'b00000001 + hundreds;
		tens = tens - 7'b0001010;
		tens2 = tens[3:0];
	end else if (tens >= 7'b0010100 && tens < 7'b0011110) begin // If tens >= 20 && tens < 30, add 2 to hundreds and subtract 20 from tens
		hundreds = 7'b0000010 + hundreds;
		tens = tens - 7'b0010100;
		tens2 = tens[3:0];
	end else if (tens >= 7'b0011110 && tens < 7'b0101000) begin // If tens >= 30 && tens < 40, add 3 to hundreds and subtract 30 from tens
		hundreds = 7'b0000011 + hundreds;
		tens = tens - 7'b0011110;
		tens2 = tens[3:0];
	end else if (tens >= 7'b0010100 && tens < 7'b0110010) begin // If tens >= 40 && tens < 50, add 4 to hundreds and subtract 40 from tens
		hundreds = 7'b0000100 + hundreds;
		tens = tens - 7'b0010100;
		tens2 = tens[3:0];
	end else if (tens >= 7'b0110010 && tens < 7'b0111100) begin // If tens >= 50 && tens < 60, add 5 to hundreds and subtract 50 from tens
		hundreds = 7'b0000101 + hundreds;
		tens = tens - 7'b0110010;
		tens2 = tens[3:0];
	end else if (tens >= 7'b0111100) begin // If tens >= 60, add 6 to hundreds and subtract 50 from tens
		hundreds = 7'b0000110 + hundreds;
	end else begin// If there is no overflow, assign as normal
		tens2 = tens[3:0];
	end

//#100
	if (unsignedNum > 10'b1111100111) begin // If unsigned Num > 999, cap hundreds2, tens2, and ones2 at 9
		hundreds2 = 4'b1001;
		tens2 = 4'b1001;
		ones2 = 4'b1001;
	end
//#100

	
	if (nothing == 1'b1) begin // If nothing signal is high, put dashes on all 4 displays
		hundreds2 = 4'b1111;
		tens2 = 4'b1111;
		ones2 = 4'b1111;
	end
	
	
	
end


//=======================================================
//  Structural coding
//=======================================================



endmodule
