
//`timescale 1 ns / 1 ns

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

// Our grand and final project. Playing whack-a-mole using the board's accelerometer.



module top(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO
);

////////////////////////////////////////////////////////////////////
///////////////////ACCELEROMETER////////////////////////////////////
////////////////////////////////////////////////////////////////////
//===== Declarations 
   localparam SPI_CLK_FREQ  = 200;  // SPI Clock (Hz)
   localparam UPDATE_FREQ   = 1;    // Sampling frequency (Hz)

   // clks and reset
   wire reset_n;
   wire clk, spi_clk, spi_clk_out;

   // output data
   wire data_update;
   wire [15:0] data_x, data_y;

//===== Phase-locked Loop (PLL) instantiation. Code was copied from a module
//      produced by Quartus' IP Catalog tool.
pll	pll_inst (
   .inclk0 ( MAX10_CLK1_50 ),
   .c0 ( clk ),                 // 25 MHz, phase   0 degrees
   .c1 ( spi_clk ),             //  2 MHz, phase   0 degrees
   .c2 ( spi_clk_out )          //  2 MHz, phase 270 degrees
   );

//===== Instantiation of the spi_control module which provides the logic to 
//      interface to the accelerometer.
spi_control #(     // parameters
      .SPI_CLK_FREQ   (SPI_CLK_FREQ),
      .UPDATE_FREQ    (UPDATE_FREQ))
   spi_ctrl (      // port connections
      .reset_n    (reset_n),
      .clk        (clk),
      .spi_clk    (spi_clk),
      .spi_clk_out(spi_clk_out),
      .data_update(data_update),
      .data_x     (data_x),
      .data_y     (data_y),
      .SPI_SDI    (GSENSOR_SDI),
      .SPI_SDO    (GSENSOR_SDO),
      .SPI_CSN    (GSENSOR_CS_N),
      .SPI_CLK    (GSENSOR_SCLK),
      .interrupt  (GSENSOR_INT)
   );

//===== Main block


// Pressing KEY0 freezes the accelerometer's output
assign reset_n = KEY[1];
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

//=======================================================
//  REG/WIRE declarations
//=======================================================
reg [2:0] state, state_c; // States 1-5 000 001 010 011 100
reg [26:0] threeSec; reg [26:0] threeSec_c; 
reg [22:0] point2Sec; reg [22:0] point2Sec_c;
reg [27:0] nine99Sec; reg [27:0] nine99Sec_c;
reg [2:0] fourGamesPlayed; reg [2:0] fourGamesPlayed_c;
wire [9:0] moleLED;
wire [15:0] smooth_outWire;
reg molePressed;
wire [7:0] out0; wire [7:0] out1; wire [7:0] out2; wire [7:0] out3; //Timer

wire [7:0] out00; wire [7:0] out11; wire [7:0] out22; wire [7:0] out33; //Games 1-4
wire [7:0] out000; wire [7:0] out111; wire [7:0] out222; wire [7:0] out333; 
wire [7:0] out0000; wire [7:0] out1111; wire [7:0] out2222; wire [7:0] out3333; 
wire [7:0] out00000; wire [7:0] out11111; wire [7:0] out22222; wire [7:0] out33333; 

reg [15:0] display; reg [15:0] display_c;
reg nothing; reg nothing_c;
reg [7:0] HEX2Reg; wire [7:0] HEX2Wire; // Reason for this is so HEX2 always has the decimal point on
reg moleEnable;
reg [9:0] LEDrs; reg [9:0] LEDrs_c;
wire [9:0] board_posit;
reg smooth_filt_en; reg [18:0] fiftyhz_c; reg [18:0] fiftyhz;
reg [27:0] time1; reg [27:0] time2; reg [27:0] time3; reg [27:0] time4; // For the time of 4 games 


initial begin
	nothing = 1'b0;
	HEX2Reg[7] = 1'b0;
	moleEnable = 1'b0;
	smooth_filt_en = 1'b0;
end

moleCtr moleCounter(
	.clk(clk),
	.moleLED(moleLED),
	.enable(moleEnable)
);

smoothing_filter smoothing_filter_inst (
	.data_x(data_x),
	.c0_sig(c0_sig),
	.filtLength(SW[1:0]),
	.enable(smooth_filt_en),
	.smooth_out(smooth_outWire)
);

remapper remap_inst(
	.smooth_out(smooth_outWire),
	.board_posit(board_posit)
);


//BCDConverter BCDConverter_inst (
//	.unsignedNum(smooth_outWire),
//	.nothing(nothing),
//	.ones2(out0),
//	.tens2(out1),
//	.hundreds2(out2)
//);

BCDConverter BCDnine99 (
	.unsignedNum(nine99Sec[27:18]),
	.nothing(nothing),
	.ones2(out0),
	.tens2(out1),
	.hundreds2(out2)
);

BCDConverter game1 (
	.unsignedNum(time1[27:18]),
	.nothing(nothing),
	.ones2(out00),
	.tens2(out11),
	.hundreds2(out22)
);

BCDConverter game2 (
	.unsignedNum(time2[27:18]),
	.nothing(nothing),
	.ones2(out000),
	.tens2(out111),
	.hundreds2(out222)
);

BCDConverter gam3 (
	.unsignedNum(time3[27:18]),
	.nothing(nothing),
	.ones2(out0000),
	.tens2(out1111),
	.hundreds2(out2222)
);

BCDConverter game4 (
	.unsignedNum(time4[27:18]),
	.nothing(nothing),
	.ones2(out00000),
	.tens2(out11111),
	.hundreds2(out22222)
);
//=======================================================
//  Structural coding
//=======================================================
// Put what each state is doing in this FSM
// Connect these to smoothing filter and such
// @ state or reset_n or threeSec or point2Sec or nine99Sec or fourGamesPlayed or molePressed
always @(*) begin // For N.S Combinational Logic
//	state_c = state; // hold previous state
	case (state) // Check which state it is currently in
		3'b000: begin // Initial state, dashes for 3 seconds
					if (threeSec == 27'b000000000000000000000000000) begin
						fourGamesPlayed_c = fourGamesPlayed + 3'b001;
						state_c = 3'b001; // Go to next state
						threeSec_c = 27'b100011110000110100011000000; // 3 seconds (According to a 25Mhz Clock, this counter counts down 1 bit every cycle. 3 sec = 75 million cycles)
						end
					else begin
						threeSec_c = threeSec - 27'b000000000000000000000000001; // Count down from 3 seconds
						display_c = 16'b0000111111111111; // Display state 0, and 3 dashes (1111 = dash)
						state_c = 3'b000; // Stay in state 0
						end
				end
				
		3'b001: begin // State 1, Mole flashes for .2 seconds
					if (point2Sec == 23'b00000000000000000000000) begin //If .2 seconds has passed
						state_c = 3'b010; // Go to next state
						point2Sec_c = 23'b10011000100101101000000; // .2 Seconds (i.e 5,000,000 cycles)
						LEDrs_c = 10'b0000000000;
						end
					else if (point2Sec == 23'b10011000100101101000000) begin // Sample the mole value
						moleEnable = 1'b1;
						point2Sec_c = point2Sec - 23'b00000000000000000000001;
						state_c = 3'b001;
					end
					else begin // Else keep counting down
						LEDrs_c = moleLED;
						moleEnable = 1'b0;
						point2Sec_c = point2Sec - 23'b00000000000000000000001;
						state_c = 3'b001;
						display_c = 16'b0001000000000000;
						end
				end
				
		3'b010: begin // 2nd State, Count down from 9.99 while the user tries to hit the mole
					if ( (nine99Sec == 28'b0000000000000000000000000000) || (molePressed == 1'b1) ) begin // If the timer has counted down from 9.99 or the mole has been pressed
						molePressed = 1'b0;
						
						if (fourGamesPlayed == 3'b001)
							time1 = nine99Sec;
						else if (fourGamesPlayed == 3'b010)
							time2 = nine99Sec;
						else if (fourGamesPlayed == 3'b011)
							time3 = nine99Sec;
						else if (fourGamesPlayed == 3'b100)
							time4 = nine99Sec;
							
						nine99Sec_c = 28'b1110111000101110000111110000; // 9.99 Seconds (i.e 249,750,000 cycles)
						LEDrs_c = 10'b0000000000;
						state_c = 3'b011;

						end
					else begin // Else keep counting down
						nothing_c = 1'b0;
						nine99Sec_c = nine99Sec - 28'b0000000000000000000000000001;
						LEDrs_c = board_posit; // Updates where the LED is
						state_c = 3'b010;
						display_c[15:12] = 4'b0010;
						display_c[11:0] = {out2,out1,out0}; // Hundreds, tens, ones 
							if (fiftyhz == 19'b0000000000000000000) begin
								smooth_filt_en = 1'b1;
								fiftyhz_c = 19'b1111010000100100000;
							end
							else begin
								smooth_filt_en = 1'b0;
								fiftyhz_c = fiftyhz - 19'b0000000000000000001; // 50 hz signal for smoothing filter
							end 
						
							if ( (KEY[0] == 1'b0) && (moleLED == board_posit) ) begin
								molePressed = 1'b1;
							end
						
					end
				end
				
		3'b011: begin // 3rd State, just show previous time for 3 seconds on HEX2-HEX0
					if (threeSec == 27'b000000000000000000000000000) begin
							if (fourGamesPlayed == 3'b100) begin
								state_c = 3'b100;
								fourGamesPlayed_c = 3'b001;

							end
							else begin
							
								state_c = 3'b000;
							end
					end
					
					else begin
						if (fourGamesPlayed == 3'b001)
							display_c[11:0] = {out22,out11,out00};
						else if (fourGamesPlayed == 3'b010)
							display_c[11:0] = {out222,out111,out000};
						else if (fourGamesPlayed == 3'b011)
							display_c[11:0] = {out2222,out1111,out0000};
						else if (fourGamesPlayed == 3'b100)
							display_c[11:0] = {out22222,out11111,out00000};

						display_c[15:12] = 4'b0011;
						threeSec_c = threeSec - 27'b000000000000000000000000001;
						state_c = 3'b011;
						
					end
				end
		3'b100: begin // 4th State, showcase all the times of the game in a loop
						if (threeSec == 27'b100011110000110100011000000) begin
							if (fourGamesPlayed == 3'b001) begin
								display_c[15:12] = 4'b0001;
								display_c[11:0] = {out22,out11,out00};
								fourGamesPlayed_c = 3'b010;
							end
							else if (fourGamesPlayed == 3'b010)begin
								display_c[15:12] = 4'b0010;
								display_c[11:0] = {out222,out111,out000};
								fourGamesPlayed_c = 3'b011;
							end
							else if (fourGamesPlayed == 3'b011) begin
								display_c[15:12] = 4'b0011;
								display_c[11:0] = {out2222,out1111,out0000};
								fourGamesPlayed_c = 3'b100;
							end
							else if (fourGamesPlayed == 3'b100) begin
								display_c[15:12] = 4'b0100;
								display_c[11:0] = {out22222,out11111,out00000};
								fourGamesPlayed_c = 3'b001;
							end
						end
					threeSec_c = threeSec - 27'b000000000000000000000000001; // Count down
					
					if (threeSec == 27'b000000000000000000000000000) // If counted down, go back to top
						threeSec_c = 27'b100011110000110100011000000; 
					//display_c = 16'b0100000000000000; //Says it is state 5
					state_c = 3'b100;
					// Loop the times from each round
					//Only way out is to reset back to state 0
		end
	
	//default c_fff = 1'b0;
	endcase
	
	if (reset_n == 1'b0) begin // If KEY[0] pressed, reset and go to state 0
		state_c = 3'b000;
		threeSec_c = 27'b100011110000110100011000000;
		point2Sec_c = 23'b10011000100101101000000;
		nine99Sec_c = 28'b1110111000101110000111110000;
		fourGamesPlayed_c = 3'b000;
		nothing_c = 1'b1;
		LEDrs_c = 10'b0000000000;
		fiftyhz_c = 19'b1111010000100100000;

	end
end

always @(posedge clk) begin // Initializing flip flops
	state <= #1 state_c;
	threeSec <= #1 threeSec_c;
	point2Sec <= #1 point2Sec_c;
	nine99Sec <= #1 nine99Sec_c;
	fourGamesPlayed <= #1 fourGamesPlayed_c;
	nothing <= #1 nothing_c;
	display <= #1 display_c;
	LEDrs <= #1 LEDrs_c;
	fiftyhz <= #1 fiftyhz_c;
end

assign LEDR = LEDrs;

seg7 u0 (
	.bit4(display[3:0]),
	.hexOutput(HEX0)
);

seg7 u1 (
	.bit4(display[7:4]),
	.hexOutput(HEX1)
);

seg7 u2 (
	.bit4(display[11:8]),
	.hexOutput(HEX2Wire)
);

seg7 u3 (
	.bit4(display[15:12]),
	.hexOutput(HEX4)
);


always @(*) begin
	HEX2Reg[6:0] = HEX2Wire[6:0];
end

assign HEX2 = HEX2Reg;
assign HEX3 = 8'b11111111;
assign HEX5 = 8'b11111111;



endmodule

// What does the smoothing filter do in this lab? - for reducing randomness from noise. Fixes output
// ROM - 4 words, maximum 2 b
// Timer for .2s and such, in the slides. Generate signal that switches every 2 s or 3 s. Frequency divider 25Mhz to 2 Hz or .33 Hz, et/ Figure out how many bits that is to divide. logbase2(x)